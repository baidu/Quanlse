#!/usr/bin/python3
# -*- coding: utf8 -*-

# Copyright (c) 2021 Baidu, Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Default SchedulerPipeline for QuanlseSchedulerSuperconduct.
"""

from numpy import array

from Quanlse.Scheduler.SchedulerPipeline import SchedulerProcess
from Quanlse.Scheduler import Scheduler
from Quanlse.QWaveform import QJob


def findMaxT(layer: list, scheduler: Scheduler) -> list:
    """
    Find maximum time for each layer

    :param layer: circuit list
    :param scheduler: a Scheduler object
    :return: a list containing the maximum time in each layer
    """
    maxDepth = [0 for _ in range(len(layer))]
    for layIdx, lay in enumerate(layer):
        for gateIdx in range(len(lay)):
            if lay[gateIdx] is not None:
                someJob = scheduler.findGatePulsePair(lay[gateIdx])
                if someJob.t > maxDepth[layIdx]:
                    maxDepth[layIdx] = someJob.t
    return maxDepth


def toLayer(layer: list, scheduler: Scheduler) -> None:
    """
    Turn gates in a Scheduler object into layers

    :param layer: empty list to store circuit
    :param scheduler: a Scheduler object
    :return: None
    """
    for gate in scheduler.circuit:
        if len(gate.qRegIndexList) == 1:
            layer[gate.qRegIndexList[0]].append(gate)
        elif len(gate.qRegIndexList) >= 2:
            fillUp(layer, gate.qRegIndexList)
            for qubit in gate.qRegIndexList:
                layer[qubit].append(gate)


def fillUp(layer: list, qubits: list = None) -> None:
    """
    Fill up till each list is of equal size

    :param layer: circuit list
    :param qubits: qubit indexes to fill
    :return: None
    """
    if qubits is None:
        qubits = range(len(layer))

    lens = [len(layer[qubit]) for qubit in qubits]
    for qubit in qubits:
        if max(lens) - len(layer[qubit]) != 0:
            N = [None] * (max(lens) - len(layer[qubit]))
            layer[qubit] = layer[qubit] + N


def addToJob(layer: list, aScheduler: Scheduler, maxT: list, aJob: QJob) -> None:
    """
    Add the circuit in the given layer to scheduler.job

    :param layer: circuit list
    :param aScheduler: original Scheduler object
    :param maxT: a list generated by findMaxt()
    :param aJob: the QJob object to add the pulses to
    """
    t0 = 0
    # for each layer
    for i in range(len(layer)):
        temp = []

        # for each qubit
        for j in layer[i]:

            # dont add the same gate multiple times
            flag = False
            for tp in temp:
                if tp == j and j is not None:
                    flag = True
            if j is not None and flag is False:
                obj = aScheduler.findGatePulsePair(j)
                aJob.appendJob(obj.pulses, t0)
            temp.append(j)
        t0 += maxT[i]


def leftAligned(job: QJob, scheduler: Scheduler) -> QJob:
    """
    The left alignment strategy for scheduling.

    :param job: job to be returned
    :param scheduler: Scheduler object containing the circuit information
    :return: the returned QJob object
    """

    # Initialize layers
    layer = []
    for i in range(scheduler.subSysNum):
        layer.append([])

    # First convert gates in Scheduler to layers
    toLayer(layer, scheduler)
    fillUp(layer)

    # Transpose layers
    layer = array(layer).T.tolist()

    # Find max time for each layer
    maxi = findMaxT(layer, scheduler)

    # clear Waves
    job.clearWaves()
    job.clearCache()

    # add waves to job
    addToJob(layer=layer, aScheduler=scheduler, maxT=maxi, aJob=job)

    job.buildWaveCache()

    return job


def defaultPipeline() -> SchedulerProcess:
    """
    Output a default SchedulerPipeline object.
    """
    process = SchedulerProcess("LeftAligned", leftAligned)
    return process
